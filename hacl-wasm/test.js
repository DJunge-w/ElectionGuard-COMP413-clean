// A demo file for using the low-level WHACL* (WASM-HACL*) bindings.
//
// Run this demo with `node main.js` from the `dist/wasm` directory of HACL*.
// Alternatively, `npm install -g http-server && http-server .` from
// `dist/wasm`, then open `main.html` in a browser to get the benefits of e.g.
// Chrome debugging.
//
// WHACL* (also known as hacl-wasm) compiles directly from F*/Low* to WASM using
// the krml compiler. This means that the resulting code is small,
// minimalistic, and does not link to libc. This also means that rather than
// trusting all of the LLVM optimizations passes, it suffices to audit the rules
// from the S&P'19 paper.
//
// There are two APIs for WHACL*:
// - the high-level API is JS-friendly, uses ArrayBuffer's, and copies data in
//   and out between JS and the WASM stack for each function call
// - the low-level API, which requires knowledge of the krml-wasm calling
//   convention.
//
// This file demonstrates how to use the latter efficiently.

// HELPERS
// -------
function p8(n) {
  return ("0"+Number(n).toString(16)).slice(-2);
}

function p32(n) {
  return p8((n >>> 24) & 255) + p8((n >>> 16) & 255) + p8((n >>> 8) & 255) + p8(n & 255);
}

// DEMO
// ----
//
// Caveats:
// - right now, every single WASM file is loaded; this is inefficient, but will
//   be fixed later.
function test_bignum64({ reserve, dump, my_print, hex }, { Hacl_Bignum64, Karamel: { mem } }) {
  // The WASM code, as generated by krml, maintains a stack. The stack pointer
  // (top of the stack) can be acquired as follows.
  let m32 = new Uint32Array(mem.buffer);
  let sp = m32[0];

  // The `reserve` function grows the stack, and returns the address of the
  // freshly-allocated memory; it is the responsibility of the JS caller to
  // restore the stack afterwards. It is also the responsibility of the JS
  // caller to align memory by reserving dummy amounts of memory.
  reserve(mem, (8 - sp % 8));
  let a = reserve(mem, 8);
  let b = reserve(mem, 8);
  let c = reserve(mem, 8);
  let d = reserve(mem, 16);
  // We cast the WASM memory as bytes, and proceed to write out so sample
  // numbers for this test.
  let m8 = new Uint8Array(mem.buffer);
  m8[a] = 0x41;
  m8[b] = 0x42;
  m8[c] = 0x43;
  console.log("a", p32(a), "b", p32(b), "c", p32(c));
  // The dump function allows dumping the WASM memory for debugging purposes.
  dump(mem, 2048, 0x13000);

  // This function heap-allocates. Technically, heap allocations are not
  // supported by the WASM backend, but I added something specifically for
  // bignums.
  // - The heap is at the end of the memory.
  // - The last 32-bit integer in memory contains the current size of the heap.
  // - Each allocation is prefixed by an 8-byte header:
  //   - first 4 bytes = allocation size (including header)
  //   - next 4 bytes = reserved
  //   - data follows.
  // - Nothing is ever freed or compacted.
  // In short, treat the heap as a region allocator, with a single region.
  //
  // Conceivably, an advanced user could directly write out this representation
  // on the stack rather than go through the helper.
  let pa = Hacl_Bignum64.Hacl_Bignum64_new_bn_from_bytes_le(8, a);
  let pb = Hacl_Bignum64.Hacl_Bignum64_new_bn_from_bytes_le(8, b);
  let pc = Hacl_Bignum64.Hacl_Bignum64_new_bn_from_bytes_le(8, c);
  let pd = Hacl_Bignum64.Hacl_Bignum64_new_bn_from_bytes_le(16, d);
  console.log("function returned four heap-allocated pointers: pa", p32(pa),
    "pb", p32(pb), "pc", p32(pc), "pd", p32(pd));
  console.log("current heap size", p32(m32[mem.buffer.byteLength/4-1]));
  dump(mem, 2048, mem.buffer.byteLength - 2048);

  // At this stage, I strongly suggest reading comments in Hacl_Bignum64.h...
  // note that now the reasoning switches to a number of /limbs/ and since my
  // demo bignums are 8 bytes, the length of pc is 1 limb (not 8!).
  console.log("demo-ing functions with context");
  let pctx = Hacl_Bignum64.Hacl_Bignum64_mont_ctx_init(1, pc);
  // And also reading the types in code/bignum/Hacl_Bignum64.fsti, here it's ok
  // to alias source and destination... note the requirement that the
  // destination (final argument) be double the length...!
  // d = a * b
  Hacl_Bignum64.Hacl_Bignum64_mul(1, pa, pb, pd);
  // a = d mod n
  Hacl_Bignum64.Hacl_Bignum64_mod_precomp(pctx, pd, pa);
  // Write back internal heap-allocated representation back onto the stack.
  Hacl_Bignum64.Hacl_Bignum64_bn_to_bytes_le(8, pa, a);
  let result = hex(m8, a, 8);
  if (result != "0200000000000000")
    throw new Error("Unexpected result!");
  console.log("Final result: 0x41*0x42 % 0x43 == ", result);

  // Reset stack pointer to what it was previously.
  m32[0] = sp;
  // Blast away all heap allocations (one may want to scrub this too, if they're
  // ultra cautious!). All of the p* variables become unusable.
  m32[mem.buffer.byteLength/4-1] = 0;

  console.log("done");
  return 0;
}

function test_bignum256({ reserve, dump, my_print, hex }, { Hacl_Bignum256, Karamel: { mem } }) {
  let m32 = new Uint32Array(mem.buffer);
  let sp = m32[0];

  // New API: aligned stack allocation
  let a = reserve(mem, 8*4, 8);
  let b = reserve(mem, 8*4, 8);
  let c = reserve(mem, 8*4, 8);

  // Abusing the fact that the allocations are contiguous.
  let m8 = new Uint8Array(mem.buffer);
  for (let i = 0; i < 3*8*4; ++i)
    m8[a+i] = 0xff;

  console.log(Hacl_Bignum256.Hacl_Bignum256_add_packed(a, b, c));
}

function main(helpers, imports) {
  // test_bignum64(helpers, imports);
  test_bignum256(helpers, imports);
}

var my_imports = {
  EverCrypt_TargetConfig: (mem) => ({
    hacl_can_compile_vale: 0,
  }),
};

if (typeof module !== "undefined")
  module.exports = { main, my_importsÂ };
